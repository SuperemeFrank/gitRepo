# JAVA学习笔记

## 编译型语言和解释型语言

**编译型语言**指使用专门编译器，针对特定平台（操作系统）将源代码一次性翻译成可被该平台硬件执行的机器码。由于编译语言是一次性编译成机器码，所以可以脱离开发环境独立运行，运行起来效率高，但是跨平台性低。常用的：JAVA、C、C++、Pascal等语言（编译语言中java和c其实也有区别）。

**解释型语言**指使用通用的解释器，根据平台的不同将源代码直接解释成机器语言让机器立即执行（并不会产生中间文件，而是直接执行！），解释器是通用的，从而实现解释型语言的跨平台性。解释型语言相当于把编译型语言中的编译和解释过程混合到一起同时完成。

如图：

![language](graphs/language.png)

可以看到**编译型语言**有两种：**第一种**如C++，直接编译成机器可以执行的二进制文件给机器执行；**第二种**如java，先编译成.class文件然后通过JVM解释成二进制文件给机器执行（这也是为什么java比C++要慢一些，因为多了JVM解释的一步，但java也因此可以跨平台）。**解释型语言**通过解释器直接生成机器代码让机器立即执行，因此解释型语言不能脱离解释器独立运行，但是因为解释器使解释型语言可以跨平台运行；可以认为解释型语言每一次运行都会编译一次，因为解释型语言不会产生中间文件（如java .class文件等），而编译型语言可以一次编译多次执行，这也导致解释型语言运行效率比编译型语言要低很多。（现在已经有很多方案来对解释型语言的运行进行优化）

## JAVA是强类型语言

java语言是一种强类型语言，即每一个变量和每一个表达式都有一个在编译时就确定的类型。每一个变量都必须先声明类型，才能使用。变量的类型限制了变量所能被赋予的值，限制了这些变量可进行的操作。

java支持数据类型分为两类：

* 基本数据类型：

	* **整数类型**
	* **字符类型**
	* **浮点类型**
	* **布尔类型**

* 引用类型：类、接口、数组类型，引用类型变量其实就是**指针**。（null 是一种特殊的引用类型）

### 字符类型和整数类型

* 字符常量必须用单引号，String必须用双引号。
* char类型一共可以表示65535个字符，所以char值可以直接转化为整数类型，范围是0~65535。将一个char变量直接赋予一个int变量，int变量显示的是这个char变量的内容在**字符表中**的值。
* 可以给char变量直接赋予0~65535间的int值，会自动转化成某一个字符，原理跟上面相同。（但不能给char变量直接赋予int变量）

### 浮点类型
* float（单精度） 占4字节32位， double（双精度） 占8字节64位。double精度更高，占内存更高。 float类型**默认使用double类型**，要使用单精度float后面需要加f或(float a=5.12f)。
* 只有浮点数才能用科学计数法
* 只有浮点数除以0才能得到正负无穷大。

### 基本类型转换
-
#### 自动类型转换

java中基本类型的自动转化图如下：

![type-change](graphs/type.png)

	注意：当将任何基本类型的与字符串进行连接运算时，基本类型值将自动转换为字符串类型。

#### 强制类型转换

强制类型转换就是上图的逆转换，因此必须要强制转换。用法:`targetType value1=(targetType)value2`

通常字符串类型不能直接转化为基本数据类型，但是通过基本类型的包装类可以实现转换，(java 8种基本类都提供了包装类)比如：

```
String a="45";
int iValue=Integer.parseInt(a);

```
#### 表达式类型自动提升

当一个表达式包含多个基本类型时，**整个表达式的数据类型将自动提升为最高等级的数据类型**。除法亦然，如果最高等级是int，除出来有小数则小数部分自动被去除。

## 流程控制与数组

### Switch分支语句

需要注意的一点是case 中可以没有break。switch 语句**只做出一次判断**，因此如果匹配的case没有break就会顺序执行后面case语句中的模块，直到遇到break才会停止。

### for循环语句

for循环语句`for(初始化语句;条件判断语句;迭代语句)`,其中只有两个分号是必要的，如果是`for(;;)`则死循环（默认一直为true）。可以看到：

```
int count =2
for(;count<10;){
	...
	count++;
}
```

这种写法就跟while循环非常相像。

### 数组

数组也是一种类型，它要求数组中所有元素都是相同的类型（基本类型或引用类型都可以）。定义数组：`type[] name`或`type name[]`推荐使用第一种。

**数组初始化：**数组初始化就是为数组 *分配空间* 和 *赋予初始值*，两者 **缺一不可**！初始化分为两种：

* **静态初始化**：由程序员显示指定初始值`arrayname=new type[]{
 element1,element2,...}`
 
* **动态初始化：**只指定数组的长度，由系统为每个元素设定初始值`arrayname=new type[3]`

	* byte/short/int/long初始为0
	* float/double初始为0.0
	* char为 '\u0000'
	* boolean 为 false
	* 引用类型为 null、

java中其实没有二维数组，虽然可以`type[][] name`来定义，但是实质也是一个一维数组，只不过一维数组中的元素也是引用而已。

### foreach循环

java 5后的一种新循环，用来**自动迭代遍历数组或者集合**，用法类似：`for(book:books){}`。循环会自动将每一个books数组的元素赋值给book并执行一次循环。  

	注意，book 只是一个临时变量，所以改变book值并不能影响数组中的值。

## 堆内存和栈内存

### 什么是堆和栈

当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。**所以说栈是一个临时的为一个方法服务的内存空间，里面存放方法的参数或者引用对象的变量**   
堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。**堆内存是一个相对稳定的内存空间，为整个程序服务。在堆内存中的对象，只有当没有任何引用变量引用它时，它才会被垃圾回收机制回收。**

### 一个堆栈说明实例：

代码：

```
public class test {
	public static void main(String[] args) {
		int[] a={1,2,3};//引用变量a指向一个新的数组
		int[] b=new int[4];//引用变量b指向一个新的数组
		System.out.println("b数组长度："+b.length);
		b=a;//将b指向的数组改到与a相同
		System.out.println("新的b数组长度"+b.length);
	}
}
```   

输出：

```
b数组长度：4
新的b数组长度3
[Finished in 0.8s]
```

改变的并不是引用变量b之前指向数组的长度，而是b指向的对象。**定义并初始化一个数组后，内存中分配了两个空间，一个用于存放数组的引用变量（即栈内存），一个用于存放数组本身（堆内存）**
下面是运行时内存示意图：
![heap_stack1](graphs/heap_stack1.png)

刚创建时，b指向第一个数组，a指向第二个数组。

![heap_stack2](graphs/heap+stack2.png)

`b=a`之后，引用变量b指向第二个数组，第一个数组没有引用对象引用它，变成了垃圾，等待垃圾回收站来回收它。

	注意：如果初始化了一个引用数组，引用数组中的元素都是引用，那么这个引用数组实体还是存储在**堆内存中的**，引用它的变量存储在栈内存中！

放两张JVM运行时内存图：
![jvm_stack&hrap](graphs/jvm_stack&heap.png)

![](graphs/jvm_run.png)










